
## 代码

#### golang代码
```go
func sortedArrayToBST(nums []int) *TreeNode {
    var dfs func([]int, int, int) *TreeNode
    dfs = func(n []int, low int, high int) *TreeNode{
        if low > high {
            return nil
        }
        //若使用 mid := (low + high)/2, 理论上有可能会发生整型越界
        mid := low + (high - low) / 2
        //选取中间元素作为根节点
        root := &TreeNode{Val: n[mid]}
        //使用根节点的左侧数组构造左子树
        root.Left = dfs(n, low, mid - 1)
        //使用根节点的右侧数组构造右子树
        root.Right = dfs(n, mid + 1, high)
        return root
    }
    return dfs(nums, 0, len(nums)-1)
}
```
#### java代码
```java
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        return dfs(nums, 0, nums.length-1);
    }
    private TreeNode dfs(int[] nums, int low, int high){
        if(low > high){
            return null;
        }
        int mid = low + (high-low)/2;
        TreeNode root = new TreeNode(nums[mid]);
        root.left = dfs(nums, low, mid - 1);
        root.right = dfs(nums, mid + 1, high);
        return root;
    }
}
```
## 时空复杂度

时间复杂度 O(N)
空间复杂度 O(N) //递归调用栈为logN，并需要开辟大小为N的空间存储数组
