## 题目描述

给你一个字符串 s，找到 s 中最长的回文子串。

示例 1：

> 输入：s = "babad"
>
> 输出："bab"
>
> 解释："aba" 同样是符合题意的答案。

示例 2：

> 输入：s = "cbbd"
>
> 输出："bb"

提示：

-    1 <= s.length <= 1000
-    s 仅由数字和英文字母组成

## 代码

#### java代码

```` java
class Solution {
    public String longestPalindrome(String s) {
        int len = s.length();
        if(len < 2){
            return s;
        }
        char[] ca = s.toCharArray();
        boolean[][] dp = new boolean[len][len];

        int maxLen = 1;
        int begin = 0;

        for(int i = 0; i < len; i++){
            dp[i][i] = true;
        }

        for(int j = 0; j < len; j++){
            for(int i = 0; i < j; i++){
                if(ca[i] != ca[j]){
                    dp[i][j] = false;
                }
                else{
                    if(j - i < 3){
                        dp[i][j] = true;
                    }
                    else{
                        dp[i][j] = dp[i+1][j-1];
                    }
                }

                if(dp[i][j] && j-i+1 > maxLen){
                    maxLen = j-i+1;
                    begin = i;
                }
            }
        }
        return s.substring(begin, begin + maxLen);
    }
}
````

#### golang代码

```` golang
func longestPalindrome(s string) string {
    len := len(s)
    if len < 2 {
        return s
    }
    maxLen := 1
    begin := 0
    dp := make([][]bool, len)
    for i := range dp {
		dp[i] = make([]bool, len)
	}
    for i:= 0; i < len; i++ {
        dp[i][i] = true
    }
    for j := 0; j < len; j++ {
        for i := 0; i < j; i++ {
            if s[i] != s[j] {
                dp[i][j] = false
            } else {
                if j - i < 3 {
                    dp[i][j] = true
                } else {
                    dp[i][j] = dp[i+1][j-1]
                }
            }
            if dp[i][j] && maxLen < j - i + 1 {
                maxLen = j - i + 1
                begin = i
            }
        }
    }
    return s[begin : begin + maxLen]
}
````

## 时空复杂度

时间复杂度：O(N2)，这里 N 是字符串的长度

空间复杂度：O(N2)，使用了一张二维表格记录所有可能的情况，因此空间复杂度是 O(N2)
